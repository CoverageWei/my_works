1、在 Java 编程中，一般使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。
NIO 与原来的 I/O 有同样的作用和目的，但是它使用不同的方式：块 I/O。

原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。

Channel 和 Buffer 是 NIO 是两个最基本的数据类型抽象；
Buffer:是一块连续的内存块，是 NIO 数据读或写的中转地；
Channel:数据的源头或者数据的目的地，用于向 buffer 提供数据或者读取 buffer 数据，buffer 对象的唯一接口。
	异步 I/O 支持


FileChannel：用于对文件的读、写、映射、锁定等操作

NIO 中的读：

第一步是获取通道。
FileInputStream  fin = new FileInputStream( “test.txt" );
FileChannel  fc = fin.getChannel();

下一步是创建缓冲区：
ByteBuffer buffer = ByteBuffer.allocate( 1024 );

最后，需要将数据从通道读到缓冲区中：
fc.read( buffer );


阻塞I/O通信模型有两个缺点：
1. 当客户端多时，会创建大量的处理线程。每个线程都要占用栈空间和CPU时间
2. 阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的

NIO工作原理：
把整个过程切换成小的任务，通过任务间协作完成。
由一个专门的线程来处理所有的 IO 事件，并负责分发。
事件驱动机制：事件到时触发，而不是同步地去监视事件。
线程通讯：线程之间通过 wait、notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的进程切换。

异步 I/O 是一种 没有阻塞件地 读写数据的方法。通可过注册对特定 I/O 事件的兴趣 ，例如可读数据的到达、新的套接字连接等等，当发生这些事时，系统将会主动通知读或者写操作。

异步 I/O 的一个优势在于，它允许您同时根据大量的输入和输出执行 I/O。同步程序常常要求助于轮询，或者创建许多线程以处理大量的连接。使用异步 I/O，您可以监听任何数量的通道上的事件，不用轮询，也不用额外的线程


Java NIO的服务端只需启动一个专门的线程来处理所有的 IO 事件，java NIO采用了双向通道（channel）进行数据传输，而不是单向的流（stream），在通道上可以注册感兴趣的事件。一共有以下四种事件：
服务端接收客户端连接事件
客户端连接服务端事件
读事件
写事件

服务端和客户端各自维护一个管理通道的对象，我们称之为selector，该对象能检测一个或多个通道 (channel) 上的事件.
以服务端为例，如果服务端的selector上注册了读事件，而NIO的服务端会在selector中添加一个读事件。
服务端的处理线程会轮询地访问selector，如果访问selector时发现有感兴趣的事件到达，则处理这些事件，如果没有感兴趣的事件到达，则处理线程会一直阻塞直到感兴趣的事件到达为止。某时刻客户端给服务端发送了一些数据，则将触发读的事件处理过程。
异步 I/O 中的核心对象名为 Selector。Selector 就是注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象给出通知，告知发生事件.

首先需要创建一个 Selector：
Selector selector = Selector.open();
然后，将对不同的通道对象调用 register() 方法，以便注册对这些对象中发生的 感兴趣的I/O 事件。






